#pragma kernel CSMain

float TerrainWidth;
float TerrainLength;
float TerrainHeight;

int DensityMapResolution;
Texture2D<float4> DensityMap;

int TerrainHeightMapResolution;
Texture2D<float4> TerrainHeightMap; //Todo float4 -> float1

struct SamplePoint
{
    float2 bayerMatrixUV;
    float2 densityMapUV;
    float2 heightMapUV;
    float threshold;
};
StructuredBuffer<SamplePoint> samplePoints; 
struct FoliagePoint
{
    float4x4 TRSMat;
    float3 worldNormal;
    int foliageType;
};
RWStructuredBuffer<FoliagePoint> foliagePoints;

float4x4 m_translate(float4x4 m, float3 v)
{
    float x = v.x, y = v.y, z = v.z;
    m[0][3] = x;
    m[1][3] = y;
    m[2][3] = z;
    return m;
}

float4x4 quaternion_to_matrix(float4 quat)
{
    float4x4 m = float4x4(float4(0, 0, 0, 0), float4(0, 0, 0, 0), float4(0, 0, 0, 0), float4(0, 0, 0, 0));

    float x = quat.x, y = quat.y, z = quat.z, w = quat.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;

    m[0][0] = 1.0 - (yy + zz);
    m[0][1] = xy - wz;
    m[0][2] = xz + wy;

    m[1][0] = xy + wz;
    m[1][1] = 1.0 - (xx + zz);
    m[1][2] = yz - wx;

    m[2][0] = xz - wy;
    m[2][1] = yz + wx;
    m[2][2] = 1.0 - (xx + yy);

    m[3][3] = 1.0;

    return m;
}

float4x4 m_scale(float4x4 m, float3 v)
{
    float x = v.x, y = v.y, z = v.z;

    m[0][0] *= x; m[1][0] *= y; m[2][0] *= z;
    m[0][1] *= x; m[1][1] *= y; m[2][1] *= z;
    m[0][2] *= x; m[1][2] *= y; m[2][2] *= z;
    m[0][3] *= x; m[1][3] *= y; m[2][3] *= z;

    return m;
}

float4x4 trs(float3 position, float4 quat, float3 scale)
{
    float4x4 m = quaternion_to_matrix(quat);
    m = m_scale(m, scale);
    m = m_translate(m, position);
    return m;
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    int targetIndex = groupIndex + groupID.x * 64;
    SamplePoint samplePoint = samplePoints[targetIndex];
    float density = DensityMap[samplePoint.densityMapUV * DensityMapResolution].g;

    if(density > samplePoint.threshold)
    {
        //1. samplePoint에서의 worldPosition 계산
        FoliagePoint foliagePoint = (FoliagePoint)0;
        float terrainWorldHeight = TerrainHeightMap[samplePoint.heightMapUV * TerrainHeightMapResolution] * TerrainHeight * 2.0f; //To Do : 이거 왜 2배 해야함??
        
        float3 worldPosition = float3(TerrainWidth * samplePoint.heightMapUV.x,
            terrainWorldHeight, TerrainLength * samplePoint.heightMapUV.y);
        foliagePoint.TRSMat = trs(worldPosition, float4(0.0f, 0.0f, 0.0f, 1.0f), float3(1.0f, 1.0f, 1.0f));
        // foliagePoint.TRSMat = trs(float3(0.0f, 0.0f, 0.0f), float4(0.0f, 0.0f, 0.0f, 1.0f), float3(1.0f, 1.0f, 1.0f));
        
        //2. samplePoint에서의 worldNormal 계산
        
        foliagePoints[targetIndex] = foliagePoint;
    }
    else
    {
        foliagePoints[targetIndex] = (FoliagePoint)0;
    }
}


